%include {
#include "var.h"
#include "basic/lexer.h"
#include "string.h"
#include "standard.h"
#include <stdbool.h>

// Exclude all debug shit
// #define NDEBUG

#include "hal.h"
#include <stdarg.h>
typedef struct file FILE;

#define fprintf(a, ...) hal_debug(__VA_ARGS__)

// epic assertion fake:
static void assert(int x, char const * xstr)
{
	if(x) return;
	hal_debug("Assertion failed: '%s'\n", xstr);
	while(true);
}
#define assert(x) assert(x, #x);

typedef union {
	int number;
	variable_t * var;
} token_t;

static int result;

}

%token_type {token_t}  
%token_prefix TOK_

%left PLUS MINUS.
%left DIVIDE TIMES.
   
%syntax_error {  
  printf("Syntax error!\n");
}
   
program ::= expr(A).                  { result = A.number; }
program ::= expr(A) ASS variable(V).  {
	var_set(V.var, &A.number);
	result = A.number;
}

variable(V) ::= VAR(A).                { V = A; }

expr(A) ::= expr(B) MINUS  expr(C). { A.number = B.number - C.number; }  
expr(A) ::= expr(B) PLUS   expr(C). { A.number = B.number + C.number; }  
expr(A) ::= expr(B) TIMES  expr(C). { A.number = B.number * C.number; }  
expr(A) ::= expr(B) DIVIDE expr(C). {
	if(C.number != 0){
		A.number = B.number / C.number;
	}else{
		printf("divide by zero\n");
	}
}

expr(A) ::= BRO expr(B) BRC. { A = B; }

expr(A) ::= INTEGER(B). { A = B; }

expr(A) ::= VAR(B). { 
	var_get(B.var, &A.number);
}

% code {
	static char prealloc[1024];

	static void *mwrap(size_t size)
	{
		return prealloc;
	}

	static token_t nulltoken = { 0 };
	
	int execute(char const *input)
	{
		// Enables tracing on parser errors
		// ParseTrace(10, "TRACE: ");
		
		void* pParser = ParseAlloc (mwrap);
		while(true)
		{
			struct token token = lex(input);
			if(token.type >= 0)
			{
				token_t currtok;
				
				static char buffer[64];
				mem_set(buffer, 0, sizeof(buffer));
				mem_copy(buffer, input, token.length);
				
				switch(token.type)
				{
					case TOK_INTEGER:
					{
						currtok.number = str_to_int(buffer, 10);
						break;
					}
					case TOK_VAR:
					{
						currtok.var = var_byname(buffer);
						break;
					}
				}
				
				hal_debug("Recognized token: %s(%d)\n", yyTokenName[token.type], token.type);
				
				Parse(pParser, token.type, currtok);
				
				if(token.type == 0)
					break;
			}
			input += token.length;
			if(*input == 0)
				break;
		}
		
		Parse(pParser, 0, nulltoken);
		
		ParseFree(pParser, free );
		
		return result;
	}
}