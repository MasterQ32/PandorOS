	%token_type {int}  
%token_prefix TOK_

%left PLUS MINUS.   
%left DIVIDE TIMES.  
   
%include {
#include "basic/lexer.h"
#include "string.h"
#include "standard.h"
#include <stdbool.h>

// Exclude all debug shit
// #define NDEBUG

#include "hal.h"
#include <stdarg.h>
typedef struct file FILE;

#define fprintf(a, ...) hal_debug(__VA_ARGS__)

// epic assertion fake:
static void assert(int x, char const * xstr)
{
	if(x) return;
	hal_debug("Assertion failed: '%s'\n", xstr);
	while(true);
}
#define assert(x) assert(x, #x);


static int result;
}  
   
%syntax_error {  
  printf("Syntax error!\n");
}   
   
program ::= expr(A).   { result = A; }  

expr(A) ::= expr(B) MINUS  expr(C). { A = B - C; }  
expr(A) ::= expr(B) PLUS   expr(C). { A = B + C; }  
expr(A) ::= expr(B) TIMES  expr(C). { A = B * C; }  
expr(A) ::= expr(B) DIVIDE expr(C). {
	if(C != 0){
		A = B / C;
	}else{
		printf("divide by zero\n");
	}
}

expr(A) ::= BRO expr(B) BRC. { A = B; }

expr(A) ::= INTEGER(B). { A = B; } 

% code {
	static char prealloc[1024];

	static void *mwrap(size_t size)
	{
		return prealloc;
	}

	int execute(char const *input)
	{
		// Enables tracing on parser errors
		// ParseTrace(10, "TRACE: ");
		
		void* pParser = ParseAlloc (mwrap);
		while(true)
		{
			struct token token = lex(input);
			if(token.type >= 0)
			{
				// printf ("  (%d, %d): '", token.type, token.length);
				// conwrite(input, token.length);
				// printf("'\n");
				static char buffer[64];
				mem_set(buffer, 0, sizeof(buffer));
				mem_copy(buffer, input, token.length);
				int value = str_to_int(buffer, 10);
				
				Parse(pParser, token.type, value);
				
				if(token.type == 0)
					break;
			}
			input += token.length;
			if(*input == 0)
				break;
		}
		
		Parse(pParser, 0, 0);
		
		ParseFree(pParser, free );
		
		return result;
	}
}